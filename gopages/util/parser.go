// Copyright 2010 Abiola Ibrahim <abiola89@gmail.com>. All rights reserved.
// Use of this source code is governed by New BSD License
// http://www.opensource.org/licenses/bsd-license.php
// The content and logo is governed by Creative Commons Attribution 3.0
// The mascott is a property of Go governed by Creative Commons Attribution 3.0
// http://creativecommons.org/licenses/by/3.0/

package util

import (
	"os"
	"path"
	"io/ioutil"
	"strings"
	"fmt"
)

var (
	comment      = "//Generated by gopages%s, do not edit\n//This file will be overwritten during build\n\n"
	method       = `func Render(context WebContext){
                                        print := func(toPrint ...interface{}){
                                                context.WriteString( fmt.Sprint(toPrint))
                                        }

                                        formValue := func(keyToGet string) string{
                                                return context.GetParams()[keyToGet]
                                        }
                                        print(""); formValue("")// prevent initialization runtime error
			`
	importstring = "\nimport(\n"
	printstring  = "io.WriteString(conn, `%s`)\n"

	//directory where generated codes will be stored
	DIR = path.Join(os.Getenv("PWD"), "pages")
)
//Page type
type Page struct {
	imports       []string
	page          string
	content       string
	generatedPage string
	parsed        bool
}
// create a new instance of page
func NewPage(page string) (p *Page, err os.Error) {
	p = new(Page)
	p.page = page
	f, err := os.OpenFile(page, os.O_RDONLY, 0666)
	f.Close()
	return
}
// parse the page and stores the resulting string in the buffer
// use ParseToFIle instead to write to string to file
func (this *Page) Parse() (err os.Error) {
	data, err := ioutil.ReadFile(this.page) //reads file into memory
	if err != nil {
		return
	}
	importsParser := NewQuoteParser(string(data), "{{", "}}")
	imports, p, er := importsParser.Next()
	if er != nil {
		err = er
		return
	}
	content := importsParser.String()
	if len(strings.TrimSpace(p)) > 0 {
		content = p
	}
	this.imports = strings.Fields(imports)
	buffer := NewStringBuilder(fmt.Sprintf("%spackage %s\n", fmt.Sprintf(comment, " from "+this.page), "pages"))
	buffer.Append(importstring)
	for _, im := range this.imports {
		if im != "io" && im != "http" && im != "fmt" {
			buffer.Append(fmt.Sprintf("\"%s\"\n", im))
		}
	}
	buffer.Append("\t\"io\"\n\t\"http\"\n\t\"fmt\"\n\t\"os\"\n )\n")
	pg := strings.Split(this.page, "/", 0)
	pg = strings.Split(strings.Join(pg, ""), ".", 0)
	buffer.Append(fmt.Sprintf(method, strings.Join(pg, "")))
	codeParser := NewQuoteParser(content, "<?go", "?>")
	err = codeParser.Parse()
	if err != nil {
		err = os.NewError("error from " + this.page + " :" + err.String())
		return
	}
	codes, html := codeParser.Parsed(), codeParser.Outer()
	for i, code := range codes {
		buffer.Append(fmt.Sprintf(printstring, html[i]))
		buffer.Append(fmt.Sprintf("%s\n", code))
	}
	buffer.Append("\n}\n")
	this.content = buffer.Content()
	return nil
}
// behaves like Parse but writes to the corresponding output file
func (this *Page) ParseToFile() (err os.Error) {
	if this.parsed {
		return
	}
	err = this.Parse()
	if err != nil {
		return
	}
	tmp := strings.Split(this.page, "/", 0)
	tmp = strings.Split(strings.Join(tmp, ""), ".", 0)
	this.generatedPage = path.Join(DIR, strings.Join(tmp, "")+".go")
	err = ioutil.WriteFile(this.generatedPage, []byte(this.content), 0666)
	if err != nil {
		return
	}
	this.parsed = true
	err = Format(this.generatedPage)
	return
}
// formats the source code using gofmt
func Format(source string) (err os.Error) {
	gofmt := os.Getenv("GOBIN")
	if len(gofmt) == 0 {
		gofmt = path.Join(os.Getenv("HOME"), "bin", "gofmt")
	} else {
		gofmt = path.Join(gofmt, "gofmt")
	}
	//fd := []*os.File{os.Stdin, os.Stdout, os.Stderr}
	_, file := path.Split(source)
	//id, err := os.ForkExec(gofmt, []string{"", "-w", file}, os.Environ(), dir, fd)
	//id, err := os.Exec(gofmt, []string{"", "-w", file}, os.Environ())
	err = os.Exec(gofmt, []string{"", "-w", file}, os.Environ())
	if err != nil {
		panic("exec returned but succeeded")
	}
	/*} else {
		os.Wait(id, 0)
	}*/
	return err 
}
//codes that will be generated
const (
	httphandler = "http.Handle(\"/%s\", http.HandlerFunc(Render%s))\n"
	init2        = "func init%s(){\n%s\n%s\n}\n"
	startserver = `func Run(address string) (err os.Error){
						println("gopages serving on", address)
						err = http.ListenAndServe(address, nil)
						return
					}
					`
	forbidden   = `
		func RenderGoPagesForbidden(conn *http.Conn, request *http.Request){
			conn.WriteHeader(403)
			conn.Write([]byte("<h1>403 Forbidden</h1>"))
		}
		`
	fileHandler = `
		http.Handle("/", http.HandlerFunc(func(conn *http.Conn, request *http.Request){
			if request.URL.Path == "/"{
				defaultPage := "%s"
				if strings.TrimSpace(defaultPage) != ""{
					http.Redirect(conn, defaultPage, 307)
				}
				return
			}
			val := "%s" + request.URL.Path
			input,err := os.Open(val, os.O_RDONLY, 0666)
			if err!=nil{
				conn.WriteHeader(404)
				conn.Write([]byte("<h1>404 Not Found</h1>"))
				return
			}
			s, _ := input.Stat()
			conn.SetHeader("Content-Length", fmt.Sprintf("%d", s.Size))
			conn.SetHeader("Content-Type", mime.TypeByExtension(strings.ToLower(path.Ext(val))))
			conn.WriteHeader(200)
			http.ServeFile(conn, request, val)
		}))
		`
)
//add handlers to specified pages in settings file
func AddHandlers(pages []string) (err os.Error) {
	initOthers := func(k, i int) string {
		if k <= len(pages) {
			return fmt.Sprintf("init%d()\n", i+1)
		}
		return ""
	}
	for i, j, k := 0, 0, 1000; j < len(pages); i++ {
		p := fmt.Sprintf("handler%d.go", i)
		if i == 0 {
			p = "handler.go"
		}
		file := path.Join(DIR, p)
		l := len(pages) - j
		var slice []string
		if l < 1000 {
			slice = pages[j:]
		} else {
			slice = pages[j:k]
		}
		buffer := NewStringBuilder(fmt.Sprintf("%spackage %s\n", fmt.Sprintf(comment, ""), "pages"))
		buffer.Append(importstring)
		imports := []string{"fmt", "os", "mime", "path", "strings", "http"}
		for _, im := range imports {
			buffer.Append(fmt.Sprintf("\"%s\"\n", im))
		}
		buffer.Append("\n)\n")
		handlers := NewStringBuilder("")
		for _, page := range slice {
			pg := strings.Split(page, "/", 0)
			pg = strings.Split(strings.Join(pg, ""), ".", 0)
			p := strings.Join(pg, "")
			l0 := len(path.Ext(page))
			wp := page[1 : len(page)-l0]
			l0 = len(Config["srcfolder"][0])
			wp = wp[l0:]
			handlers.Append(fmt.Sprintf(httphandler, wp, p))
			handlers.Append(fmt.Sprintf(httphandler, page[l0+1:], "GoPagesForbidden"))
		}
		if k > len(pages) {
			buffer.Append(startserver)
			buffer.Append(forbidden)
			handlers.Append(fmt.Sprintf(fileHandler, Config["default"][0], Config["srcfolder"][0]))
			handlers.Append(fmt.Sprintf(httphandler, Config["srcfolder"][0], "GoPagesForbidden"))
			handlers.Append(fmt.Sprintf(httphandler, "pages", "GoPagesForbidden"))
		}
		st := fmt.Sprintf("%d", i)
		if i == 0 {
			st = ""
		}
		buffer.Append(fmt.Sprintf(init2, st, handlers.Content(), initOthers(k, i)))
		err = ioutil.WriteFile(file, []byte(buffer.Content()), 0666)
		if err != nil {
			return
		}
		err = Format(file)
		if err != nil {
			return
		}
		j += 1000
		k += 1000
	}
	return
}
